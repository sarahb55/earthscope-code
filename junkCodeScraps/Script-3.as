/*This work was supported in part bythe National Science Foundationunder grant DUE-0535327.Tutorials by Doug Ensley and Barbara Kaskosz.A Simple Function Grapher - Part 1.Last modified: May 28, 2007.*//*The first command prevents our applet from being rescaledby, for example, maximizing the Player's window or changingthe HTML settings. We don't want the applet to be rescaled sincetoo much in it relies on pixel calculations.*/stage.scaleMode="noScale";var timer:Timer = new Timer(100);timer.addEventListener(TimerEvent.TIMER, onTimer);var startVal:int = 0;timer.start();var amplitude:Number = 0;var period:Number = 0.5;var count:Number = 1;var pixArray:Array=[];/*The x and y ranges in this part of the tutorial remain fixed, so we couldsimply hard-wire the values -10, 10, -10, 10 into our code.However, that would make the code hard to modify and accommodatedifferent range values. Hence, we store the values for x and yranges in the next four numerical variables.*/var nXmin:Number=-10;var nXmax:Number=10;var nYmin:Number=-10;var nYmax:Number=10;/*We will create a graphing board programmatically by drawinga square on the Stage at runtime. We could draw our square directlyin the main movie, but it will be more convenient later to haveour graphing board reside in a separte container. We will createan instance of Sprite to serve as our container.In terms of functionality, instances of the Sprite class (new in AS3)are between MovieClips and Shapes (the Shape class is also new in AS3). You can draw in Shapes but they do not respond to events and cannothave "children"; that is, Shapes cannot contain other display objects.Sprites can have children, you can draw in them, and they respondto events. MovieClips share all the functionality of Spritesplus they can have an independent timeline. The Sprite which will serve as our graphing board is stored ina variable spBoard.*/var spBoard:Sprite=new Sprite();/*When a visual object like a Sprite is created, it resides in theAVM (ActionScript Virtual Machine), but it is not rendered on screenuntil it is added to the Display List; that is, added as a childof an object already displayed on screen. Below, we makespBoard a child of the main movie. */this.addChild(spBoard);/*We set the position of spBoard using properties of the Sprite class.The position set below is the position of the origin, (0,0),of the internal coordinate system of spBoardwith respect to the upper left corner of the Stage. Recall,that in Flash the x coordinate is increasing as we go to the right,the y coordinate as we go down. It is true in themain movie as well as in local coordinate systems of Sprites,MovieClips, and Shapes. If we didn't set the x and y positionof spBoard, it would be positioned by defaultat the (0,0) of the main movie; that is; at the upper left corner of the main movie.*/spBoard.x=58;spBoard.y=54;/*The x, y positon of spBoard becomes the origin of the localcoordinate system in spBoard; i.e., (0,0) within spBoard.It is important to remember since all drawing will take placein spBoard.*//*The size of the graphing board will remain fixedin this applet: we will draw a 320 by 320 square in spBoardand that will serve as our board. The code will be easier to modifyif we store the size of the board, 320, in a variable, nSize.All the conversion formulas below will then be universalfor any board size. If you want to change the sizeof the graphing board, all you need to do is to changethe value of nSize.*/var nSize:Number=320;/*The graphs of our functions will be created by evaluating a givenfunction at a number of points on the x axis, and then joiningthe resulting points on the xy-plane by linealelements. How many points should we use to obtain a smooth-lookinggraph? The natural choice is the size of the board in pixels.We store the number of points in nPoints.*/var nPoints:Number=320;/*We call a function (defined later) which draws in spBoard a white 320 by 320 square where our graphs will reside.*/drawBoard();/*We create two Shapes, shAxes and shGraph, in which we willdraw the x and the y axes and graphs of our functions. We add the shapes as children of spBoard so they willbe rendered on screen.*/var shAxes:Shape=new Shape();spBoard.addChild(shAxes);var shGraph:Shape=new Shape();spBoard.addChild(shGraph);/*We want the movie to open with the axes drawn. Hence, we calldrawAxes function. The function (defined later in the script)will be executed when the movie opens.*/drawAxes();initGraph();/*The function drawBoard defined below drawsa white square with a black border in spBoard.Graphing in Sprites, Shapes, or MovieClips is donethrough the graphics property of those classes.Hence, the word "graphics" in the syntax. We could use the new method for drawing rectangles   spBoard.graphics.drawRect(0,0,320,320)as follows:  function drawBoard():void {    spBoard.graphics.lineStyle(1,0x000000);		spBoard.graphics.beginFill(0xFFFFFF);		spBoard.graphics.drawRectangle(0,0,nSize,nSize);		spBoard.graphics.endFill();	  }		We chose to use the moveTo(..), lineTo(...) techniquesince it is much more universal.The method moveTo(a,b) moves the imaginary "drawing pen"to the point (a,b); lineTo(c,d) draws the linefrom the current position of the pento the point (c,d).lineStyle(thickness,color) sets the thickness of the line(in pixels) and its color (passed in hex).*/function drawBoard():void {		//We set the thickness and the color of the stoke.		spBoard.graphics.lineStyle(1,0x000000);		//We set the color of the fill.		spBoard.graphics.beginFill(0xFFFFFF);		//We draw a rectangle by drawing four sides.		spBoard.graphics.moveTo(0,0);		spBoard.graphics.lineTo(nSize,0);		spBoard.graphics.lineTo(nSize,nSize);		spBoard.graphics.lineTo(0,nSize);		spBoard.graphics.lineTo(0,0);		spBoard.graphics.endFill();		}	/*The next function draws the x and y axes in the shAxes, a Shapecontained in spBoard. It calculates pixel equivalents of x=0,y=0 and uses the "moveTo" and "lineTo" graphics methods to draw the axes.Again, since the range is fixed, the point (x,y)=(0,0) translates to the point(160,160) in pixel terms. But if we hard-wire those valueswe will not be able to reuse the code for in the case whenthe x and y ranges vary.*/function drawAxes(): void {				var yzero:Number;				var xzero:Number;				/*		We clear all previous drawings in shAxes.		*/				shAxes.graphics.clear();				//We set the thickness and the color of the stroke.				shAxes.graphics.lineStyle(1,0x000000);				/*		We translate (0,0) into pixel terms using the conversion functions		defined later.		*/				yzero=ytoPix(0);			    xzero=xtoPix(0);				//We draw the axes.			    shAxes.graphics.moveTo(0, yzero);			    shAxes.graphics.lineTo(nSize,yzero);			    shAxes.graphics.moveTo(xzero,0);			    shAxes.graphics.lineTo(xzero,nSize);							}	/*The next function is a helper function which returns the valueof sine for a given value of a. If we want to change the functionbeing graphed all we need to do is to modify calcFunValue.Note, we are using the built in Math.sin(..) method.*/	function calcFunValue(a:Number):Number {				var amp = amplitude*count;		trace(amp);		var v:Number = amp*Math.sin(1/period*a);				return v;		}function initGraph():void {		/*	The next variable is an array that will consist of points	in spBoard between which lineal elements will be drawn.	*/		var pixArray:Array=[];		//A counter integer.		var i:int;		/*	xstep is the length in functional terms beween two	points on the x axes at which sine will be evaluated.		*/	var xstep:Number;			/*	The current functional values for x and for y will be stored	in curx and cury.	*/		var curx:Number;		var cury:Number;			/*	Clearing all previous graphs in shGraph.		*/				shGraph.graphics.clear();		/*	The value of xstep depends on the x range and the number of points	at which the function to be graphed is going to be evaluated.	*/		xstep=(nXmax-nXmin)/nPoints;		for(i=0;i<=nPoints;i++){				curx=nXmin+xstep*i;				cury=calcFunValue(curx + startVal);					 /*      We are preparing the array of points (each point is itself a two-element array)      which will be joined by lineal elements to produce the graph. First,      we calulated the current x value, curx, in functional terms by adding xstep*i to nXmin,      and then the functional value of y, cury, which is obtained by applying      the function calcFunValue (defined above) to curx. The latter function      gives the value of the sine as this is the function we used in calcFunValue.      Then we translate curx, cury values to pixel values      relative to spBoard's origin,(0,0). The origin of spBoard coincides with	  the upper left corner of our square. We are using xtoPix and ytoPix      functions to obtain the pixel equivalents.	*/		 		pixArray[i]=[];				pixArray[i]=[xtoPix(curx),ytoPix(cury)];				}		shGraph.graphics.lineStyle(1,0xFF0000);		for(i=0;i<nPoints;i++){					/*		We are now drawing the lineal elements comprising the graph.		*/				shGraph.graphics.moveTo(pixArray[i][0],pixArray[i][1]);				shGraph.graphics.lineTo(pixArray[i+1][0],pixArray[i+1][1]);					}				}	/*The next function, drawGraph, plots the graph of the sine(or, more precisely, of the function defined within clacFunValue).The function will be called when the butSine is clicked.*/function drawGraph():void {		/*	The next variable is an array that will consist of points	in spBoard between which lineal elements will be drawn.	*/			//A counter integer.		var i:int;		/*	xstep is the length in functional terms beween two	points on the x axes at which sine will be evaluated.		*/	var xstep:Number;			/*	The current functional values for x and for y will be stored	in curx and cury.	*/		var curx:Number;		var cury:Number;			/*	Clearing all previous graphs in shGraph.		*/				shGraph.graphics.clear();		/*	The value of xstep depends on the x range and the number of points	at which the function to be graphed is going to be evaluated.	*/		xstep=(nXmax-nXmin)/nPoints;		for(i=0;i< nPoints;i++){						curx=nXmin+xstep*i;				cury=calcFunValue(curx + startVal);					 /*      We are preparing the array of points (each point is itself a two-element array)      which will be joined by lineal elements to produce the graph. First,      we calulated the current x value, curx, in functional terms by adding xstep*i to nXmin,      and then the functional value of y, cury, which is obtained by applying      the function calcFunValue (defined above) to curx. The latter function      gives the value of the sine as this is the function we used in calcFunValue.      Then we translate curx, cury values to pixel values      relative to spBoard's origin,(0,0). The origin of spBoard coincides with	  the upper left corner of our square. We are using xtoPix and ytoPix      functions to obtain the pixel equivalents.	*/		 		pixArray[i]=[];				pixArray[i]=[xtoPix(curx),ytoPix(cury)];				}		shGraph.graphics.lineStyle(1,0xFF0000);		for(i=0;i<nPoints - 1;i++){					/*		We are now drawing the lineal elements comprising the graph.		*/				shGraph.graphics.moveTo(pixArray[i][0],pixArray[i][1]);				shGraph.graphics.lineTo(pixArray[i+1][0],pixArray[i+1][1]);					}				}/*The next two functions take functional values, a, for x or y and convertthem to the corresponding values in pixels relative to the upperleft corner of the graphing board which is the (0,0) point of spBoard.*/function xtoPix(a:Number):Number {				var xconv:Number=nSize/(nXmax-nXmin);				return (a-nXmin)*xconv;					}		function ytoPix(a:Number):Number {				var yconv:Number=nSize/(nYmax-nYmin);				return (nYmax-a)*yconv;				}	/*To make a button respond to events, we have to add thecorresponding event listeners to it via the addEventListener method.The method addEventListener takes two parameters:the name of an event and the reference to a callback functionthat is executed when the event happens. Note: for the codeto work, the sine button has to be assigned an instance name on the Stage,the same name we are using below. (It happens to be butSin).*/	butSin.addEventListener(MouseEvent.CLICK,graphSin);/*Because of the inner workings of the event handling model in AS3,callback functions have to take a parameter. The datatype of the parameteris the event to which the listener responds. The value of the parameterwill be generated by AS3 when the event occurs.*/function graphSin(e:MouseEvent):void {		drawGraph();	}butReset.addEventListener(MouseEvent.CLICK,resetBoard);function resetBoard(e:MouseEvent):void {		shGraph.graphics.clear();	}function onTimer(TimerEvent):void{		shGraph.graphics.clear();	startVal += 1;	amplitude += 0.01;	count--;	if(count <= 1){		count = 20;	}	drawGraph();	}