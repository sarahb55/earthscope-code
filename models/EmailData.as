/* * This Interface is for all of the game elements in the volcano game. * written by Sarah Block * November 30, 2007 */ package earthscope.models{		 import flash.events.EventDispatcher;import flash.events.Event;import earthscope.events.GameEvent;import earthscope.utils.LoadXMLFile;import earthscope.models.*;import flash.events.*;import flash.net.*;import flash.utils.*;import earthscope.events.EmailEvent;import earthscope.events.EmailUpdateEvent;		public class EmailData extends GameData{				private var warned:Boolean = false; //to do get this from TownData		private var _xml:XML = new XML();		private var _indices:Array = new Array();		private var emailFile:String = "text/beforeWarningEmails.xml";		private var index:int = 0;		private var _body:String;		private var _subject:String;		private var _from:String;		private var _reply1:String;		private var _reply2:String;		private var _done:String;		private var _changePop:int = 0;		private var _changePrep:int = 0;	 	private var _changeMoney:int = 0;	        private var dataFormat:String = URLLoaderDataFormat.TEXT;		private var _youHaveMail: Boolean = false;						public function EmailData(){			super();			init();					}				private function init(){						//load data from disk			trace("Init...");						LoadXMLFile(emailFile);						//create and randomize array					}				public function get hasMail():Boolean{						return _youHaveMail;		}				public function get subject():String{						return _subject;					}				public function get body():String{						return _body;					}				public function get from():String{						return _from;					}				public function get reply1():String{						return _reply1;		}				public function get reply2():String{						return _reply2;				}				public function get done():String{						return _done;		}				public function get popularityChange():int{			return _changePop;					}				public function get moneyChange():int{			return _changeMoney;					}				public function get prepChange():int{			return _changePrep;					}				/** 		  * Called when user replies to email.		  * Sets email flag to false.		  * Updates email text.		  *		  **/		public function reply(response:String){						_youHaveMail = false;						if(_indices.length <= 0){							return;			}						trace("In reply..." + response);						if(response == _reply1){				//to do update town variables				_body = _xml.email[index].replyYes.body;				_from = _xml.email[index].replyYes.from;				_subject = _xml.email[index].replyYes.subject;				trace(_xml.email[index].replyYes.@doneBtn);				_done =_xml.email[index].replyYes.@doneBtn;								_changePop = _xml.email[index].replyYes.@popularity;				_changePrep = _xml.email[index].replyYes.@preparation;	 			_changeMoney = _xml.email[index].replyYes.@money;								dispatchEvent(new EmailUpdateEvent(EmailUpdateEvent.REPLY_YES));											}			else{				//to do update town variables				_body = _xml.email[index].replyNo.body;				_from = _xml.email[index].replyNo.from;				_subject = _xml.email[index].replyNo.subject;				trace(_xml.email[index].replyNo.@doneBtn);				_done =_xml.email[index].replyNo.@doneBtn;								_changePop = _xml.email[index].replyNo.@popularity;				_changePrep = _xml.email[index].replyNo.@preparation;	 			_changeMoney = _xml.email[index].replyNo.@money;								dispatchEvent(new EmailUpdateEvent(EmailUpdateEvent.REPLY_NO));							}						trace("Changed variables:" + _changePop + " " + _changePrep + " " + _changeMoney);			_youHaveMail = false;					}				public function next():void{						trace("In next....");			if(_indices.length > 0){				index = _indices.shift();							}						update();								}				/**		 * Call when user clicks to leave screen updates to the next email		 */				private function update():void{						if(_indices.length > 0){							trace(_xml.email.length());				trace(_xml.email[index].body.@yesBtn);				_reply1 =_xml.email[index].body.@yesBtn;				trace(_xml.email[index].body.@noBtn);				_reply2 = _xml.email[index].body.@noBtn;				trace(_xml.email[index].body);				_body = _xml.email[index].body;				trace(_xml.email[index].subject);				_subject = _xml.email[index].subject;				trace(_xml.email.length());				_from = _xml.email[index].from;			}			else{								_body = "no mail";				_subject = "no subject";				_from = "nobody";							}					}									/**		 * This method is designed to update each time the game timer ticks. It		 * should update the internal state of the game piece based on the time.		 */		override public function tick(tick:Number):void{			trace("In email tick... _indices.length " + _indices.length + " _youHaveMail = " + _youHaveMail );			if(_youHaveMail == false && _indices.length > 0){				trace("Checking for email event...");				if(tick % 10 == 0)				{ //TO DO check probability of mail					_youHaveMail = true;					dispatchEvent(new EmailEvent(EmailEvent.YOU_HAVE_MAIL));					trace("Email Event dispatched...");				}							}					}				/**		 * This method tells the GameEngine whether or not anything needs to change		 * in the way the object is displayed.		 * @return true when drawing needs to be updated.		 * @return false if it needs no changes.		 */		override  public function updateView():Boolean{return false; }				/**		  * This method helps to sort the array to randomize the order of the emails		  *		  * @return -1 or 1 randomly		  */		private function randomSort(elementA:int, elementB:int):Number{			var val:Number = Math.random() - 0.5;			trace(val);			if(val < 0){								return 1;			}			else{								return -1;			}					}						 public function LoadXMLFile (file:String) {            			var source:String = file;			var loader:URLLoader = new URLLoader();			_xml = new XML();			_indices = new Array();			index = 0;            loader.dataFormat = dataFormat;            configureListeners(loader);            var request:URLRequest = new URLRequest(source);            try {                loader.load(request);				            } catch (error:Error) {				                trace("Error loading requested document: " + source);            }        }        private function configureListeners(dispatcher:URLLoader):void {            dispatcher.addEventListener(Event.COMPLETE, completeHandler);            dispatcher.addEventListener(Event.OPEN, openHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);        }						        private function completeHandler(event:Event):void {            var loader:URLLoader = URLLoader(event.target);            switch(loader.dataFormat) {                case URLLoaderDataFormat.TEXT :                    trace("completeHandler (text): " + loader.data);                    break;                case URLLoaderDataFormat.BINARY :                    trace("completeHandler (binary): " + loader.data);                    break;                case URLLoaderDataFormat.VARIABLES :                    trace("completeHandler (variables): " + loader.data);                    break;            }						try{																_xml = new XML(event.target.data);				trace(_xml.email.length());			 				trace(_xml.email[index].body.@yesBtn);				_reply1 = _xml.email[index].body.@yesBtn;				trace(_xml.email[index].body.@noBtn);				_reply2 = _xml.email[index].body.@noBtn;				trace(_xml.email[index].body);				_body = _xml.email[index].body;				trace(_xml.email[index].subject);				_subject = _xml.email[index].subject;				trace(_xml.email.length());				_from = _xml.email[index].from;								_indices = new Array();								for (var i:int = 1; i < _xml.email.length(); i++){										_indices.push(i);									}								if(_xml.email.length() > 2){					_indices = _indices.sort(randomSort);				}										}			catch(e:TypeError){								trace("Could not parse into xml");				trace(e.message);							}        }        private function httpStatusHandler(event:Event):void {            trace("httpStatusHandler: " + event);        }        private function ioErrorHandler(event:IOErrorEvent):void {            trace("ioErrorHandler: " + event);        }        private function openHandler(event:Event):void {            trace("openHandler: " + event);        }        private function progressHandler(event:ProgressEvent):void {            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }					}		}