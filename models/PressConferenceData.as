/* * This Interface is for all of the game elements in the volcano game. * written by Sarah Block * November 30, 2007 */ package earthscope.models{		 import flash.events.EventDispatcher;import flash.events.Event;import earthscope.events.GameEvent;import earthscope.utils.LoadXMLFile;import earthscope.models.*;import flash.events.*;import flash.net.*;import flash.utils.*;import flash.utils.*;import earthscope.events.EmailEvent;import earthscope.events.EmailUpdateEvent;import earthscope.utils.SoundPlayer;import earthscope.text.GameText;		public class PressConferenceData extends GameData{						private var _xml:XML = new XML();		private var _indices:Array = new Array();		private var _file:String = "text/pressConference.xml";		private var _index:int = 0;		private var _question:String;		private var _replies:Array = new Array();		private var _dataFormat:String = URLLoaderDataFormat.TEXT;		private var _questionsAsked:int = 0;		private var _maxQuestions:int = 4;		private var _town:TownData; 		var _correct:SoundPlayer = new SoundPlayer();							public function PressConferenceData(file:String, town:TownData){			super();			_file = file;			_town = town;			init();											}				private function init(){						//load data from disk			LoadXMLFile(_file);			_correct.loadSound(GameText.SOUNDS_FOLDER + "applause.mp3");											}				public function get intro():String{						var intro:String = _xml.intro;			return intro;		}				public function get lastQuestion():String{						return _xml.lastQuestion;		}				public function get conclusion():String{						return _xml.conclusion;		}				public function get pressQuestion():String{						return _xml.question[_index].press;					}				public function answer(i:int):String{						if(i < 0 || i >= _xml.question[_index].answers.answer.length()){								return null;			}						return _xml.question[_index].answers.answer[i];		}				public function feedback(i:int):String{						if(i < 0 || i >= _xml.question[_index].answers.feedback.length()){								return null;			}						return _xml.question[_index].answers.feedback[i];		}								public function correct(i:int):Boolean{						var retval:Boolean = false;						if(i < 0 || i >= _xml.question[_index].answers.answer.length()){								return retval;			}						trace(_xml.question[_index].answers.answer[i].@correct);						if(_xml.question[_index].answers.answer[i].@correct == "true"){								retval = true;			}						return retval;		}				/**		 * 		 *		 */				public function reply(i:int):void{						if(i < 0 || i >= _xml.question[_index].answers.answer.length()){								return;			}						if(correct(i) == true){								_town.changePrepardness(+15);				trace("update town preparation +");				_correct.play();			}			else{								//to do update town preparation				_town.changePrepardness(-5);				trace("update town preparation -");			}					}				public function next():void{									if(_indices.length > 0){				_index = _indices.shift();							}						_questionsAsked++;			trace("Updating index = " + _index);		}				public function get done():Boolean{						return (_questionsAsked < _maxQuestions);					}				public function get noMoreQuestions():Boolean{						if(_indices.length > 0){								return false;			}						else{				return true;			}				}										/**		 * This method is designed to update each time the game timer ticks. It		 * should update the internal state of the game piece based on the time.		 */		override public function tick(tick:Number):void{								}				/**		 * This method tells the GameEngine whether or not anything needs to change		 * in the way the object is displayed.		 * @return true when drawing needs to be updated.		 * @return false if it needs no changes.		 */		override  public function updateView():Boolean{return false; }				/**		  * This method helps to sort the array to randomize the order of the emails		  *		  * @return -1 or 1 randomly		  */		private function randomSort(elementA:int, elementB:int):Number{			var val:Number = Math.random() - 0.5;						if(val < 0){								return 1;			}			else{								return -1;			}					}						 public function LoadXMLFile (file:String) {            			var source:String = file;			var loader:URLLoader = new URLLoader();            loader.dataFormat = _dataFormat;            configureListeners(loader);            var request:URLRequest = new URLRequest(source);            try {                loader.load(request);				            } catch (error:Error) {				                trace("Error loading requested document: " + source);            }        }        private function configureListeners(dispatcher:URLLoader):void {            			dispatcher.addEventListener(Event.COMPLETE, completeHandler);            dispatcher.addEventListener(Event.OPEN, openHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);        }						        private function completeHandler(event:Event):void {            var loader:URLLoader = URLLoader(event.target);            switch(loader.dataFormat) {                case URLLoaderDataFormat.TEXT :                    trace("completeHandler (text): " + loader.data);                    break;                case URLLoaderDataFormat.BINARY :                    trace("completeHandler (binary): " + loader.data);                    break;                case URLLoaderDataFormat.VARIABLES :                    trace("completeHandler (variables): " + loader.data);                    break;            }						try{								_xml = new XML(event.target.data);								trace(_xml.question.length());				trace(_xml.question[0].press);				trace(_xml.question[0].answers.answer[0]);				trace(_xml.question[0].answers.answer[0].@correct);				trace(_xml.question[0].answers.feedback[0]);				trace(_xml.question[0].answers.answer.length());				trace(_xml.intro);				trace(_xml.lastQuestion);				trace(_xml.conclusion);				for (var i:int = 0; i < _xml.question.length(); i++){										_indices[i] = i;									}								_indices = _indices.sort(randomSort);											for ( i= 0; i < _xml.question.length(); i++){										trace(_indices[i]);									}								_index = _indices.shift();						}			catch(e:TypeError){								trace("Could not parse into xml");				trace(e.message);							}        }        private function httpStatusHandler(event:Event):void {            trace("httpStatusHandler: " + event);        }        private function ioErrorHandler(event:IOErrorEvent):void {            trace("ioErrorHandler: " + event);        }        private function openHandler(event:Event):void {            trace("openHandler: " + event);        }        private function progressHandler(event:ProgressEvent):void {            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }					}				}