/*** CollisionDetection by Grant Skinner. August 1, 2005* Visit www.gskinner.com/blog for documentation, updates and more free code.** You may distribute this class freely, provided it is not modified in any way (including* removing this header or changing the package path).** Please contact info@gskinner.com prior to distributing modified versions of this class.*/package earthscope.utils{import flash.display.BitmapData;import flash.geom.ColorTransform;import flash.geom.Matrix;import flash.geom.Rectangle;import flash.display.MovieClip;import flash.geom.Rectangle;import flash.display.*;import earthscope.views.*;public class CollisionDetection {			private var _parent:Sprite;		public function CollisionDetection(p:Sprite){_parent = p;};		public function checkForCollision(p_clip1:MovieClip,p_clip2:MovieClip,p_alphaTolerance:Number):Rectangle {				// set up default params:		if (p_alphaTolerance == undefined) { p_alphaTolerance = 255; }				// get bounds:		var bounds1:Rectangle = p_clip1.getBounds(_parent);		var bounds2:Rectangle = p_clip2.getBounds(_parent);				if( bounds1 != null){			trace(bounds1.topLeft + " bounds1 " + bounds1.bottomRight );		}						if( bounds2 != null){			trace(bounds2.topLeft + " bounds2 " + bounds2.bottomRight );		}				// rule out anything that we know can't collide:		if (((bounds1.bottomRight.x < bounds2.topLeft.x) || (bounds2.bottomRight.x < bounds1.topLeft.x)) || ((bounds1.bottomRight.y < bounds2.topLeft.y) || (bounds2.bottomRight.y < bounds1.topLeft.y)) ) {			return null;						trace("returning null");		}				// determine test area boundaries:		var bounds:Rectangle = new Rectangle();		bounds.topLeft.x = Math.min(bounds1.topLeft.x,bounds2.topLeft.x);		bounds.bottomRight.x = Math.max(bounds1.bottomRight.x,bounds2.bottomRight.x);		bounds.topLeft.y = Math.max(bounds1.topLeft.y,bounds2.topLeft.y);		bounds.bottomRight.y = Math.min(bounds1.bottomRight.y,bounds2.bottomRight.y);				// set up the image to use:		var img:BitmapData = new BitmapData(bounds.width,bounds.height);				// draw in the first image:		var mat:Matrix = p_clip1.transform.concatenatedMatrix;		mat.tx -= bounds.topLeft.x;		mat.ty -= bounds.topLeft.y;		img.draw(p_clip1,mat, new ColorTransform(1,1,1,1,255,-255,-255,p_alphaTolerance));				// overlay the second image:		mat = p_clip2.transform.concatenatedMatrix;		mat.tx -= bounds.topLeft.x;		mat.ty -= bounds.topLeft.y;		img.draw(p_clip2,mat, new ColorTransform(1,1,1,1,255,255,255,p_alphaTolerance),"difference");				// find the intersection:		var intersection:Rectangle = img.getColorBoundsRect(0xFFFFFFFF,0xFF00FFFF);				// if there is no intersection, return null:		if (intersection.width == 0) { return null; }				// adjust the intersection to account for the bounds:		intersection.x += bounds.topLeft.x;		intersection.y += bounds.topLeft.y;				return intersection;	}		}}